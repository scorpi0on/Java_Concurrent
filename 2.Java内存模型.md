# Java内存模型

> 导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是**禁用缓存和编译优化**，但是这样问题虽然解决了，我们程序的性能可就堪忧了。

Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 **volatile**、**synchronized** 和 **final** 三个关键字，以及六项 **Happens-Before 规则**

## volatile

> 原始的意义就是禁用 CPU 缓存。

## Happens-Before 规则

> **前面一个操作的结果对后续操作是可见的**

1. ### 程序的顺序性规则

2. ### volatile 变量规则

3. ### 传递性

   > JAVA 1.5 版本的并发工具包（java.util.concurrent）就是靠 volatile 语义来搞定可见性的

4. ### 管程中锁的规则

   > **管程**是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现

5. ### 线程 start() 规则

   > 主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作

6. ### 线程 join() 规则

   > 主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对**共享变量**的操作

## 总结

java内存模型解决了程序 可见性 和 有序性 的问题。